#!/usr/bin/env python3
# Masterfully formulated by Sir Dr. Rev. Peloton, Esq.

import json
import sys
import shutil
import shlex
import subprocess
import re
import os

# Set if this program seems to be selecting the wrong executable for op
OP_EXE = None

def is_wsl() -> bool:
    import platform
    return re.search("microsoft", platform.uname().release, re.IGNORECASE) != None

def get_op_exe() -> str | None:
    """Find the appropriate executable for the 1Password CLI

    Returns:
        str: Path to the 1Password CLI executable
    """
    if OP_EXE:
        return OP_EXE
        
    if is_wsl():
        return shutil.which("op.exe")
    else:
        return shutil.which("op")

def call_shell(cmd: str) -> str:
    """Calls shell within child process and returns stdout
    Args:
        cmd (str): Command to run
    Returns:
        str: Stdout of `cmd`
    """
    res = b''
    with subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE) as p:
        for line in p.stdout:
            res += line

    return str(res, 'ascii')

class SSHConfigEntry:
    def __init__(self, obj):
        # 1Password CLI always returns fields in the order specified by the command, so this can be hardcoded
        self.key = obj[0]['reference']

        # Initial blank values for all options
        self.options = self.user = self.aliases = self.url = None

        parameters: list[str] = obj[1]['value'].split('\n')
        for param in parameters:
            key, value = param.split(' ', 1)
            setattr(self, key, value)
    
    def serialize(self) -> str:
        res = f'Host {self.url} {self.aliases.replace(",", " ") if self.aliases else ""}\n'
        res += f'\tHostName {self.url}\n'
        res += f'\tIdentityFile "{self.key}"\n'
        
        if self.user:
            res += f'\tUser {self.user}\n'

        if self.options:
            opts = self.options.split(',')
            for opt in opts:
                res += f'\t{opt}\n'

        return res
    
def make_config(entries: list[SSHConfigEntry]) -> None:
    path = ''
    if is_wsl():
        # Use PowerShell to derive the Windows username if possible
        if ps := shutil.which('powershell.exe'):
            win_user = call_shell(f'{ps} \'$env:UserName\'').strip()
        else:
            print('Hi! You appear to be using WSL, so we need some extra info.')
            win_user = input('What is your Windows username? ')
            print('Thanks, back to work!')

        path = f'/mnt/c/users/{win_user}/.ssh/config'
    else:
        path = f'/home/{os.getlogin()}/.ssh/config'

    with open(path, 'w') as fout:
        fout.write('# This file was automatically generated by a Chezmoi script. Changes will be overwritten if `chezmoi apply` or `chezmoi update` is ran.\n')
        fout.write(f'# You can find the script somewhere in the directory opened with `chezmoi cd`.\n\n')

        if not is_wsl():
            fout.write('Host *\n\tIdentityAgent ~/.1password/agent.sock\n')
        for entry in entries:
            fout.write('\n')
            fout.write(entry.serialize())

def main():
    OP_EXE = get_op_exe()
    if OP_EXE is None:
        print("1Password CLI not installed! Quitting.", file=sys.stderr)
        if is_wsl():
            print("Hint: If you're trying to use WSL, you need the Windows CLI installed, not Linux!", file=sys.stderr)
        sys.exit(1)

    # Get all SSH Key entries by ID
    get_entries_res = call_shell(f'{OP_EXE} item list --categories SSHKEY --format json')
    key_ids = []
    for key in json.loads(get_entries_res):
        # Omit the signing key - this is hardcoded! :(
        if re.search('signing', key['title'], re.IGNORECASE):
            continue

        key_ids.append(key['id'])

    # Get desired fields from each entry by entry ID
    entries: list[SSHConfigEntry] = []
    for key in key_ids:
        res = call_shell(f'{OP_EXE} item get --format json --fields label="public key",label="chezmoi params" {key}')
        entry = SSHConfigEntry(json.loads(res))
        entries.append(entry)

    make_config(entries)

if __name__ == '__main__':
    main()